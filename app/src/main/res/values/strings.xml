<resources>
    <string name="app_name">AndroidDevPractice</string>

    <string name="wrong_password">Wrong Password</string>

    <string name="preference_file_key">AndroidDevPracticeFile</string>

    <string name="off">OFF</string>
    <string name="on">ON</string>


    <!--Activity-->
    <string name="activity_summary">An activity is a single focused thing that the user can do. Activities interact with the user, so the Activity class takes care of creating a window fro you in which you can place your UI with setContentView. Activities are oftten presented to the user as full screen windows they can also be used in other ways as floating windows</string>
    <string name="activity_configuration_change_summary">Configuration change occurs when the orientation of the device changes, a configuration change results in reloading of the activity and a new layout depending on orientation. You can create you unique layouts for portrait or lands scape mode.</string>

    <!--Activity Lifecycle    -->
    <string name="activity_lifecycle_summary">As a user navigates through, out of and back to your app, the Activity instances transition through different states in their lifecycle. The activity class provides a number of callbacks that allow the activity to know that a state has changed.</string>
    <string name="activity_lifecycle_onCreate">callback onCreate():
        \n This Call back fires when the system first creates an activity, onCreate handles basic application startup logic that should happen only once for the entire life of the activity. This method receives the savedInstanceState</string>
    <string name="activity_lifecycle_onRestart">callback onRestart():
        \nCalled after onStop() when the current activity is being re-displayed to the user
    </string>
    <string name="activity_lifecycle_onStart">callback onStart():
        \nMakes the activity visible to the user, as the app prepares for the activity to enter the foreground and become interactive</string>
    <string name="activity_lifecycle_onResume">callback onResume():
        \nThe app comes to the foreground, and then the system invokes onResume(). The user interacts with the app in this state, the app will stay in this state until something happens to take focus away from the app.</string>
    <string name="activity_lifecycle_onPause">callback onPause():
        \nWhen the activity leaves the foreground it will enter the onPause() state. Use onPause() to adjust operations that should not continue while the activity is not in active state. OnPause can also be used to release system resources.</string>
    <string name="activity_lifecycle_onStop">callback onStop():
        \nWhen the activity is no longer visible to the user the system will invoke the onStop(). The app should release or adjust resources that are not needed while the app is not visible to the user. When the activity enters the stopped state, the activity object maintains all state and member information, but is not attached to window manager.</string>
    <string name="activity_lifecycle_onDestroy">callback onDestroy():
        \nIs called before the activity is destroyed. The system invokes this call back for two reasons. \n 1. The Activity is finished\n 2. The system is temporarily destroying the activity due to a configuration change.</string>
    <string name="activity_lifecycle_loop_entire">Entire Life Loop:
        \nThe entire lifetime of an activity happens between the first call to onCreate() through to a single final call to onDestroy(). An activity will do all setup of global states in onCreate(), and release all remaining resources in onDestroy().</string>
    <string name="activity_lifecycle_loop_visible">Visible Life Loop:
        \nThe visible lifetime of an activity happens between a call to onStart() until a corresponding call to onStop(). During this time the user can see the activity -on-screen, though it may not be in the foreground interacting with the user.</string>
    <string name="activity_lifecycle_loop_foreground">Foreground Life Loop:
        \nThe foreground lifetime of an activity happens between a call to onResume() until a corresponding call to onPause(). During this time the activity is invisible, active and interacting with the user.</string>

    <string name="activity_process_lifecycle_summary">The Android system attempts to keep process around fo as long as possible, if memory needs to be freed up then process can be terminated. The four states of importance are listed here and will determine what process get terminated.</string>
    <string name="activity_saving_persistent_data_summary">Saving persistent data will save the data as a key value pair into a file to be loaded later.</string>

    <!-- ArchitectureComponent  Coroutines -->
    <string name="ac_coroutines_summary">Provides an API that enables allows for asynchronous code. </string>
    <string name="ac_coroutines_coroutine_scope">Coroutine Scope: \nDefines a scope for new coroutines. Every coroutine builder is an extension on CoroutineScope and inherits its coroutineContext to automatically propagate all its elements and cancellation </string>
    <string name="ac_coroutines_viewmodel_scope">ViewModelScope: \nA ViewModelScope is defined for each ViewModel. Any coroutine launched in this scope is automatically canceled if the ViewModel is cleared. </string>
    <string name="ac_coroutines_lifecycle_scope">LifecycleScope: \nA lifecycleScope is defined for each Lifecycle object. Any coroutine launched in this scope is canceled when the lifecycle is destroyed. You can access the CoroutineScope of the Lifecycle either via lifecycle.coroutineScope or lifecycleOwner.lifecycleScope properties.  </string>
    <string name="ac_coroutines_suspend">Suspend Lifecycle-aware coroutines: \nYou can suspend coroutines if they aren\'t in the minimum state.
        \n - lifecycle.whenCreated
        \n - lifecycle.whenStarted
        \n - lifecycle.whenResumed </string>
    <string name="ac_coroutines_livedata">LiveData:
        \nLiveData works with coroutines to calculate data asynchronously. When LiveData is canceled or suspends so its coroutine.  </string>
    <string name="ac_data_binding_summary">The Data Binding library is a support library that allows you to bind UI components in your layout o data sources in your app using a declarative format. DataBinding is the replacement for findViewById.</string>
    <string name="ac_data_binding_expression_language">Expression Language:
        \nAllows you to write expressions that connect variables to the view in the layout. The DB library generates the classes required to bind views in the layout with your data objects. \nVariable: Allows you to find data objects and methods to views in the layout.</string>
    <string name="ac_data_binding_generated_classes">Generated Classes:
        \nThe DB will generate binding class that are used to access the layout\'s variables and views. The generated class links the layout variables with the views in the layout.</string>
    <string name="ac_data_binding_binding_object">Binding Object:
        \nThe binding object is created immediately after inflating the layout to ensure that the view hierarchy isn\'t modified before it binds to the views with expressions in the layout. Use DataBindingUtil.inflate to inflate the binding class. In a fragment you will need to return the root of Binding object in onCreateView().</string>
    <string name="ac_data_binding_view_id">View with ID:
        \nThe DB creates a immutable filed in the binding class for each view that has an ID in the layout. The library extracts the views including the IDs fromt eh view hierarchy in a single pass. This is faster than calling findViewById for every view.</string>
    <string name="ac_data_binding_observable_data">Observable data:
        \nThe DB Library can make objects, fields or collections observable. Any object can be used with data binding but modifying the object doesn\'t automatically cause the UI to update. DB can be used to give objects the ability to notify other objects, known as listeners, when data is changed.</string>
    <string name="ac_data_binding_twoway_data_binding">Two-way DataBinding:
        \nUsing one-way data binding, you can set a value on an attribute and set a listener that reacts to a change in that attribute. The @={} notiation, includes the = sign, receives data changes to the property and listen to user updates at the same time.</string>
    <!--Architecture Components Lifecycle aware    -->
    <string name="ac_lifecycle_aware_summary">Lifecycle-aware components: perform actions in response to a change in the lifecycle status of another component, such as activities and fragments. These components help you produce better-organized, adn often lighter-weight code, that is easier to maintain. Lifecycles are managed by the operating system or the framework code running in process.</string>
    <string name="ac_lifecycle_aware_lifecycle">Lifecycle:
        \nIs a class that holds the information about the lifecycle state of a component(Activity/Fragment) and allows other objects to observe this state. Lifecycle uses two enumerations to track the lifecycle status for its associated component. /n - Event: The lifecycle events that are dispatched from the framework and Lifecycle class. These events map to callbacks in Activities and Fragments \n  - State: The current state of the component tracked by the Lifecycle object </string>
    <string name="ac_lifecycle_aware_owner">LifecycleOwner:
        \nIs a single method interface that denotes that he class has a Lifecycle. It has one method, getLifecycle(), which must be implemented by the class. The interface abstaracts the ownership of a Lifecycle from individual classes, such as Fragments and allows writing components that work with them. Components that implement Lifecycle owner work seamlessly with components that implement Lifecycle observer</string>
    <string name="ac_lifecycle_aware_best_practice">Best Practice:
        \n - Keep UI controllers as lean as possible. They should not acquire their own data, use ViewModel and observe LiveData to reflect changes.
        \n - Write data-driven UIs where the UI controllers responsibility is to update the views as data changes.
        \n - Put data logic in a ViewModel. ViewModel should server as a connector between the UI and the rest of the app
        \n - Use DataBinding to maintain a clean interface between your views and UI controller. This allows views to be more declarative and minimizes the update code.
        \n - Avoid referencing a View or activity context in the a ViewModel. If ViewModel outlives the activity, the activity leaks and isn\'t properly disposed of by the garbage collector.
        \n - kotlin coroutines to manage long-running tasks and other operations that can run asynchronously.</string>
    <string name="ac_lifecycle_aware_cases">When to use Lifecycle-aware components:
        \nComponents can make it much easier for you to manage lifecycles in a variety of cases.
        \n - LiveData allows you to automatically update the UI.\n - Stopping and starting video buffering. Lifecycleaware_components can start buffering as soon as possible but deffer playback until the app is fully loaded.
        \n - Starting and stopping network connectivity. Enable live updating of network data while an app is in the foreground and also to automatically pause when the  app goes into the background.
        \n - Pausing and resuming animated drawables. pausing animation well the app is in the background and resume animation after the app enters the foreground.</string>
    <string name="ac_lifecycle_aware_stop_events">StopEvents: \nPrevents UI changes from being called after the app is no longer in the foregrounds. </string>
    <!--Architecture Components LiveData-->
    <string name="ac_livedata_summary">Is an observable data holder class. LifeData is lifecycle aware, meaning it respects the lifecycle of other app components, This ensures that only component observers that are in the active lifecycle state are updated. </string>
    <string name="ac_livedata_observer">Observer:
        \n LiveData notifies observer objects when the lifecycle state changes.</string>
    <string name="ac_livedata_advantages">Advantages:
        \n - Ensures you UI matches data state. Any changes to LiveData the observer will update the UI.
        \n - No memory leaks, Observers are bound to lifecycle objects and clean up after themselves when their associated lifecycle is destroyed.
        \n - No crashes Due to stopped activities.
        \n No more manual lifecyle handling. UI components just observe relevant data and don\'t stop or start observation.
        \n Always upto date.
        \n Proper configuration changes.
        \n Sharing resources, LiveData can extend using the singleton pattern to wrap system services so that they can be  shared in the app.
    </string>
    <string name="ac_livedata_working_with">Working With:
        \n 1. Create an instance  of LiveData to hold a certain type of data
        \n 2. Create an observer object taht defines the onChanged(), which controls what happens when data is changed
        \n 3. Attach the observer obect to the LiveData object using observe(). The observe() method takes a LifecycleOwner object. This subscribes the observer object to the LiveData object.
    </string>
    <string name="ac_livedata_states">States:
        \n - onActive(): is called when the LiveData object has an active observer.
        \n - onInactive(): is called when the LiveData object doesn\'t have any active observers.
        \n - setValue(T): updates the value of the LiveData instance and notifies any active observes about the change.
    </string>
    <string name="ac_livedata_transform">Transform:
        \nTransformations applies a function on the value stored in LiveData object, and propagates teh result downstream.
    </string>
    <!--Architecture Components Room    -->
    <string name="ac_room_summary">The Room persistence library provides an abstraction layer over SQLite to allow for more robust database access while harnessing the full power of SQLite. The library helps create a cache of the app\'s data on a device that\'s running the app.</string>
    <string name="ac_room_entity">Entity: \nrepresents a table in the data base. Use a data class to create the entity. For each entity a table is created.  </string>
    <string name="ac_room_database">Database: \nContains the database holder and  serves as the main access point for the underlying connection tyou app\'s persisted relation data. </string>
    <string name="ac_room_dao">DAO: \nData Access Object, contains the methods used for accessing the data in the database. </string>
    <string name="ac_room_repository">Repository: \nIs responsible for interacting with the database  on behalf of the ViewModel and will need to provide methods that use the DAO.  </string>

    <!--Architecture Component ViewModel    -->
    <string name="ac_viewmodel_summary">The View Model class is designed to store and manage UI-related data in a lifecycle conscious way. The ViewModel class allows data to survive configuration changes. ViewModel replaces Loaders.</string>
    <string name="ac_viewmodel_provider">ViewModelProvider: \nA utility class that provides ViewModels scope. </string>
    <string name="ac_viewmodel_lifecycle">Lifecycle: \nViewModel objects are scoped to the lifecycle passed to the ViewModelProvider when getting the ViewModel remains in memory until the Lifecycle is scoped to go away permanently or in the case of fragment detached. </string>
    <string name="ac_viewmodel_sharedViewModel">SharedViewModel:
        \n Fragments can share ViewModels by using their activity scope to handle communication. SharedViewModel provides the following benefits.
        \n - The activity does not need to do anything, or know aything about this communication
        \n - Fragments doesn\'t need to know about each other be sides the SharedViewModel
        \n - Each fragment has its own lifecyle, and is not affected by the lifecycle of the other one.
    </string>
    <!--Architecture WorkManager-->
    <string name="ac_WorkManager_summary">WorkManager is an API used to schedule deferrable asynchronous tasks that are expected to run even if the app exits or the device restarts. WorkManager API is a suitable and recommend replacement for all previous Android background scheduling APIs. </string>
    <string name="ac_WorkManager_constraints">Constraints: \nDefine the optimal conditions for your work to run using Work Constraints. ex wait to be on Wi-Fi, device idle</string>
    <string name="ac_WorkManager_scheduling">Scheduling: \nWork can be run on-time or repeatedly using flexible scheduling windows. Work can be tagged  and named as well, allowing you to schedule unique, replaceable work and monitor or cancel groups of work together. Scheduled work is stored in an internally managed SQLite database and WorkManager takes careof ensuring that this work persists and is rescheduled across device reboots..</string>
    <string name="ac_WorkManager_retry">Retry Policy: \nWorkManager offers flexible retry polices, including a configurable exponential backoff policy.</string>
    <string name="ac_WorkManager_chaining">Work Chaining: \nFor complex related work, chain individual work tasks together using a fluent, natural,interface that allows you to control which pieces run sequentially and which run in parallel. </string>
    <string name="ac_WorkManager_integrates">Integrates: \nWorkManager intgrates seamlessly with RxJava and Coroutines and provides the flexibility to plug in your own asynchronous APIs.</string>


    <!-- Navigation    -->
    <string name="navigation_summary">Refers to the interactions that allow users to navigate through different sections of the app. JetPack\s navigation component ensures a consistent and predictable user experience by adhering to an established set of principles </string>
    <string name="navigation_graph">Navigation Graph: \nAn XML resource that contains all navigation-related information in one centralized location. This includes all of the individual content areas within your app, called destinations, as well as the possible paths that a user can take to navigate through the app.</string>
    <string name="navigation_nav_host">NavHost: \nAn empty container that displays destinations from your navigation graph. The navigation component contains a default NavHost implementation, NavHostFragment, that displays fragment destinations.</string>
    <string name="navigation_nav_controller">NavController: \nAn object that manages app navigation with a navHost. The NavController orchestrates the swapping of destination content in the NavHost as users move throughout the app.</string>
    <string name="navigation_navigation_benefits">Benefits:
        \n - Handling fragment transactions
        \n - Handling Up and Back actions correctly be default
        \n - Providing standardized resources for animations and transitions.
        \n - Implementing and handling deep link
        \n - Including Navigation UI patterns, such as navigation drawers and bottom navigation, with minimal additional work
        \n - Safe Args a gradle plugin that provides tpe safety when navigating and passing data between destinations.
        \n - ViewModel supports, you can scope a ViewModel to navigation graph to share UI-related data between the graph\'s destinations.
    </string>
    <string name="navigation_destination">Destinations: Are Activities or fragments that you can navigate to. They are added to the NavGraph.</string>
    <string name="navigation_conditional_navigation">When designing navigation for your app, ou might want to navigate to one destination versus another based on conditional logic. </string>

    <!--Navigation Principles    -->
    <string name="navigation_principles_of_navigation_fixed">Fixed Start Destination: \nThis is the first screen the user sees when they launch the app from the launcher. This destination is also the last screen the user after pressing the back button. </string>
    <string name="navigation_principles_of_navigation_stack">Stack: \nThe start destination is the base destination of what is known as the back stack and is the basis for the app\'s navigation state. The top of the stack is the current screen and the previous destinations in the stack represent the history of where you\'ve been. The back stack always has the start destination of the app at the bottom of the stack. Navigation component manages all of the back stack ordering for you can choose to manage the back stack your self.</string>
    <string name="navigation_principles_of_navigation_up_and_back">Up and Back:
        \nThe back button appears in the system navigation bar at the bottom of the screen and is used to navigate in reverse-chronological order through the history of the screens the user has recently worked with. When you press the current destination is popped off the top of the back stack, and you then navigate to the previous destination.
        \nThe Up button appears in the app bar at tht top of the screen and is identical to the back button but can\'t exit the app. </string>
    <string name="navigation_principles_of_navigation_deep_link">Deep Link: \nAllows an icon that you place on the screen to link to specified destination in the app. </string>

    <!--Navigation NavGraph    -->
    <string name="navigation_NavGraph_summary">The Navigation component uses a navigation graph too manage your app\'s navigation. A navigation graph is a resource file that contains all of the app\'s destinations along with the logical connections, or actions, that users can take to navigate from one destination to another. You can manage your app\s navigation using the navigation editor.  </string>
    <string name="navigation_NavGraph_TopLevel">TopLevel: \nTop-level navigation graph should start with the initial destination the user sees when launching the app and should include the destinations the user sees. </string>
    <string name="navigation_NavGraph_GlobalActions">Global Actions: \nA common action that multiple destinations can use. A global action is respseneted in teh Navigation Editor by a small arrow that points to the associated destiantion.</string>
    <string name="navigation_NavGraph_NestedGraphs_summary">NestedNavGraph: \nA series of destinations can be grouped into a nested graph within a parent navigation graph called the root graph. Nested graphs are useful to organize and reuse sections of your app\'s UI such as a self-contained login flow.The nested graph encapsulates its destinations. As with a root graph, a nested graph must have destination identified as the start destination. Destinations outside of the nested graph ,such as those on the root graph, access the nested graph only through its start destinationn. </string>
    <string name="navigation_NavGraph_NestedGraphs_create">Create:
        \n 1. In the NavEditor, press and hold the shift key and click on the destinations you want to include in the nested graph.
        \n 2. Right-click to open the context menu, and select Move to Nested Graph > New Graph. The destinations are enclosed in  a nested graph.
        \n 3. Click on the nested graph. The following attributes appear in the attribute panel
        \n  - Type: which contains Nested Graph
        \n  - ID: which contains a system-assigned ID of the nested graph. This ID is used to reference the nested graph in code.
        \n 4. Double click on the nested graph to show its destinations.
        \n 5. Click the text tab to show the XML view. A nested navigation graph has been added to the graph.
        \n 6. In the code pass the resource ID of the action connecting the root graph to the nested graph.
    </string>
    <!--Navigation_Navigate    -->
    <string name="navigation_Navigate_summary">Navigation to a destination is done using a navController, an object that manages app navigation within a NavHost. Each NavHost has its own corresponding NavController. NavController provides a few different ways to navigate to a destination.</string>
    <string name="navigation_Navigate_safe_args">SafeArgs: \nThe recommended way to navigate between destinations is to use the SafeArgs Gradle plugin. This plugin generates simple object and builder classes that enable type-safe navigation between destinations. SafeArgs is recommend both for navigating as well as passing data between destinations. </string>
    <string name="navigation_Navigate_with_id">Navigate with ID: \nNavigate takes the resource ID of either an action or a destination.</string>
    <string name="navigation_Navigate_action">Action: \nNavigation actions provide a level of indirection between your navigation code and the underlying destinations. This allows you to define common actions that change their destination or NavOptions based on the current NavDestination.
        \n Destination: the resource ID of the target destination.
        \n Default arguments: An android.osBundle containing default values for the target destination if supplied.
        \n Navigation options: Navigation options, represented as NavOptions. This class contains all of the special configuration for transitioning to and back from the target destination including animation resource configuration, pop behavior, and whether the destination should be lunched in a single top mode.
    </string>
    <string name="navigation_Navigate_DeepLink">DeepLink: \nCan navigate directly ot an implicit DeepLink destination or a URI </string>

    <!--Navigation Pass data -->
    <string name="navigation_PassData_summary">Navigation allows you to attach data to a navigation operation by defining arguments for a destination, Like a user ID. </string>
    <string name="navigation_PassData_Arguments">Arguments: \nTo pass data between destinations, first define the argument by adding it to the destination receiving it.</string>
    <string name="navigation_PassData_support">Support types: \nInteger, Float, Long, Boolean, String, Resource Reference, Custom Parcelable, Custom Serializable, Custom enum</string>
    <string name="navigation_PassData_safe_args">SafeArgs: \nThe recommended way to navigate between destinations is to use the SafeArgs Gradle plugin. This plugin generates simple object and builder classes that enable type-safe navigation between destinations. SafeArgs is recommend both for navigating as well as passing data between destinations. </string>


    <!--Intent    -->
    <string name="intent_summary">An Intent is messaging object you can use to request an action from another app component. There fundamental use cases.
        \n 1. Start an Activity: You can start a new instance of an Activity by passing an Intent to startActivity(). The intent describes the activiy to start and carries the necessary data.
        \n 2. Start a Service: The intent describes the service and carries the necessary data.
        \n 3. Delivering a broadcast: You can deliver a broadcast to other apps by passing an Intent to sendBroadcast() or sendOrderedBroadcast().
    </string>
    <string name="intent_types">Types:
        \n - Explicit Intent: Launch a component by name, typically in your app.
        \n - Implicit intents: Does not specify a name typically used to launch a component outside of your app.
    </string>
    <string name="intent_category">Category: \n A string containing additional information about the kind of component that should handle the intent. Any number category descriptions can be placed in a n intent but most intent do not require a category.  </string>
    <string name="intent_chooser">Chooser: \n When there is more than one app that responds to your implicit intent, the user can select which app to use and make the app the default choice for the action.</string>
    <string name="intent_receiving_implicit_intent">Receiving Implicit Intent: \nTo advertise which implicit intents your app can receive, declare one or more intents filters for each of your app components with an intent-filter in the manifest.</string>
    <string name="intent_pending_Intent">PendingIntent: /n A PendingIntent object is a warpper around an intent object. The primary purpose of a PendingIntent is to grant permission to a foreign application oto use the contained Intent as if it were executed from your app. Cases for PendingIntents
        \n - Declaring an intent to be executed when the user preforms an action with your Notification.
        \n - Declaring an intent to be executed when the user preforms an action with your app widget
        \n - Declaring an intent to be executed at a specified future time.
    </string>
    <string name="intent_resolution">Resolution: \n When the system receives an implicit itnent to start an activity, it searches for the best activity for the intent by comparing it to intent filters based on three aspeds
        \n - Action
        \n - Data
        \n - Category
    </string>


    <!-- Notification   -->
    <string name="notification_priority">Notification Priority: Is an indication of how much of the user\'s valuable attention should be consumed by this notification.</string>
    <string name="notification_visibility_public">VISIBILITY_PUBLIC: shows the notification\'s full content</string>
    <string name="notification_visibility_secret">VISIBILITY_SECRET: doesn\'t show any part of this notification on the screen</string>
    <string name="notification_visibility_private">VISIBILITY_PRIVATE: shows basic information, such as the notifications icon and the content title, but hides the notifications full content</string>
    <string name="notification_full_screen">Full Screen: Heads up notification doesn\'t close</string>
    <string name="notification_on_going">OnGoing: You cannot swipe the notification away.</string>
    <string name="notification_set_show_when">SetShowWhen: Controls whether the timestamp set with is displayed in the notification</string>


    <!--UserInterface-->
    <string name="UI_summary">UserInterface is everything that the user can see and interact with. Android provides variety of pre-built UI components such as structured layout objects and UI controls that allow you to interface such as dialogs, notification and menus. </string>
    <string name="UI_layouts_summary">A layout defines the structure for a user interface in your app, such as in activity. All elements in the layout are built using a hierarchy of View and ViewGroup objects.</string>
    <string name="UI_layouts_xml">XML: \nLayouts are typically written in XML but can be coded to</string>
    <string name="UI_layouts_load">Load Layout: \n When you compile your app, each XML layout file compiled into a View resource. Load the layout resource form Activity.onCreate(). Do so by calling setContentView(), passing the reference to the layout resource</string>
    <string name="UI_layouts_attributes">Attribute: \nEvery View and ViewGroup object supports their own variety of XML attributes. Some attributes are specific to a View object, well others are common to all View objects because they inherit the root View.  </string>
    <string name="UI_layout_parameters">Layout Parameters: \nAre layout attributes named layout_something define layout parameters for the view that are appropriate for the ViewGroup in which it resides. EveryViewGroup class implements a nested class that extends ViewGroup.LayoutParams. This subclass contains property types that define the size and position for each child view, as appropriate for the view group.  .</string>
    <string name="UI_layout_ID">ID: \nAny View object may have an integer ID associated with it, to uniquely identify the View within the tree. When the app is compiled, this ID is referenced as an integer, but the ID is typically assigned in the layout XMl file as a string, in the id attribute.The @ symbol at the beginning of the string indicates that the XML parser should parse and expand the rest of the ID string and identify it as an ID resource. The plus symbol menas that this is a new resource name that must be created and added to resources file. </string>
    <string name="UI_layout_position">Layout Position: \nThe geometry of a view is that of a rectangle. A View has a location,expressed as a pair of left and top coordinates, and two dimensions, expressed as a width and height. The unit for location and dimension is the pixel.</string>
    <string name="UI_layout_size">Size, Padding, Margins: \nThe size of a view is expressed with a width and height. A view posses two pairs of width and height values.
        \n 1. Measured width and Measured Height. These dimension define how big a view wants to be within  its parents, this includes the padding surronding the view.
        \n 2. The second pair is known as width and height. or sometimes drawing width and drawing height. These dimensions define the actual size of the view on screen, at drawing time and after layout.
    </string>

    <!--UserInterface Layouts    -->
    <string name="UI_layout_summary">Layout: Is a ViewGroup that has several child views to create a UserInterface.</string>
    <string name="UI_layout_linear">LinearLayout: \nA layout that organizes its children into a single horizontal or vertical row. </string>
    <string name="UI_layout_relative">RelativeLayout: \nEnables you to specify the location of child objects relative to each other.</string>
    <string name="UI_layout_WebView">WebView: Displays web pages. </string>
    <string name="UI_layout_adapters">Adapters: \nWhen the content for a layout is dynamic or not pre-determined, you can sue a layout that subclasses AdapterView to populate the layout with views at runtime. A subclass of the AdapterViw classs uses an Adapter to bind data to its layout. The adapter Behaves as a middleman between the data sources and the AdapterView, the Adapter retrieves the dat and converts each entry into a view that can be added into the AdapterView.</string>
    <string name="UI_layout_list">ListLayout: displays a scrolling single column list</string>
    <string name="UI_layout_gridView">Displays a scrolling grid of columns and rows. </string>
    <string name="UI_layout_constraint">ConstraintLayout: \nAllows you to create large and complex layouts with a flat view hierarchy. Defines the view\'s position by add on horizontal and one vertical constraint for the view. </string>
    <string name="UI_layout_motionLayout">MotionLayout: \nIs a layout that helps you manage motion and widget animation in your app. MotionLayout is a subclass of ConstraintLayout and builds upon its rich layout capabilities. MotionLayout bridges the gap between layout transitions and complex motion handling, offering a mix of features between the property animation framework and TransitionManager.</string>

    <!--UserInterface RecyclerView.-->
    <string name="UI_RecyclerView_summary">Is a ViewGroup that efficiently displays a large set of data. When an item scrolls off the screen RecyclerView doesn\'t destroy its view. Instead, RecyclerView reuses the view for new items that have scrolled onscreen. Reuse improves the apps responsiveness and reducing power consumption.  </string>
    <string name="UI_RecyclerView_adapter">Adapter: \nAdapters provide a binding from an app-specific data set to views that are displayed within a RecyclerView.</string>
    <string name="UI_RecyclerView_layoutManager">LayoutManager: \nThe layout manager arranges the individual elements.
        \n - LinearLayout: arranges the items in one dimensional list.
        \n - LinearLayout: arranges all items in a two-dimensional grid.
    </string>
    <string name="UI_RecyclerView_ViewHolder">ViewHolder: \nEach element in the list is defined by a ViewHolder object. ViewHolder provides all the functionality for the list items. ViewHolder is a wrapper around a view, and that view is managed by RecyclerView.  </string>
    <string name="UI_RecyclerView_onCreateViewHolder">onCreateViewHolder(): \nRecyclerView calls this method when it needs to create a new ViewHolder. The method creates and initializes the ViewHolder and its associated View, but does not fill in the view\s contents.</string>
    <string name="UI_RecyclerView_onBindViewHolder">onBindViewHolder(): \n RecyclerView calls this method to associate a ViewHolder with data. The method fetches the appropriate data and uses the data to fill in the view holder\'s layout. </string>
    <string name="UI_recyclerView_getItemCount">getItemCount(): \nRecyclerView calls this method to get the size of the list. </string>
    <string name="UI_recyclerView_diffUtils">DiffUtil: \n Is a utility class that calculates the difference between two lists and outputs the operations that convert the first lit into the second one. </string>
    <string name="UI_RecyclerView_ItemDecoration">ItemDecoration: \nItem decoration allows the application to add a drawing and a layout offset to a specific item view from the adapters data set. All Item decorations are drawing in the order they appear.</string>
    <string name="UI_RecyclerView_TouchHelper">TouchHelper: \nThis is a contract between ItemTouchHelper and the application, that allows you to control touch behavior such as slide drag.</string>


    <!--User Interface CustomView -->
    <string name="UI_CustomView_summary">Creating a CustomView subclass gives precise control over the appearance and function of screen elements.
        \n - combine a group of View components into a new single component.
        \n - Override the way a View like EditText is rendered on screen.
        \n - capture other events like key presses and handle them in some custom way.
    </string>
    <string name="UI_CustomView_basic_approach">Basic approach:
        \n 1. Extend an Existing View class or subclass.
        \n 2. Override some of the methods from the SuperClasss. The superclass method to override start with on.
        \n 3. Use your new extension class. once completed, your new extension classs can be used in place of the view upon which it was based.
    </string>
    <string name="UI_CustomView_onDraw">onDraw(): \n Delivers a Canvas upon which you can implement anything you want(2D).</string>
    <string name="UI_CustomView_onMeasure">onMeasure(): \nEfficiently and accurately reports the measurements of its contained parts.  </string>
    <string name="UI_CustomView_CompoundControls">CompoundControls: \nAre atomic reusable Views that contain multiple child controls laid out and wired together. </string>
    <string name="UI_CustomView_Canvas">Canvas: \nThe canvas class holds the draw calls. To draw something you need 4 basic components
        \n 1. Bitmap that hold the pixels,
        \n 2. Canvas to the draw calls
        \n 3. A drawing primitive(rect, Path, text, bitmap)
        \n 4. Pain.
    </string>
    <string name="UI_CustomView_paint">Paint: \nThe paint class holds the style and color informationa bout how to draw geometries, text and bitmaps. </string>

    <!--UserInterface Look and feel    -->
    <string name="UI_Look_summary">  </string>
    <string name="UI_Look_MaterialDesign">Material Design: \n is a comprehensive guide for visual, motion and interaction designed across multiple platforms and devices.</string>
    <string name="UI_Look_Styles_Themes">Styles and Themes: \nStyles and Themes on Android allow you to separate the details of your app design format and UI structure and behavior, similar to styles sheet in web design.
        \n - Styles: is a collection of attributes that specify the appearance for a single View. A style can specify attributes such as font color, font size background color and much more.
        \n - Theme: is a collection of attribute that\'s applied to an entire app, activity, or view hierarchy not just an individual view. When you apply a theme, every view in the app activity or view hierarchy.
    </string>
    <string name="UI_Look_DarkTheme">DarkTheme: \n DarkTheme is color alternative to the app and supplies the following benifits.
        \n - Reduce power usage by a significant amount
        \n - Imrpoves visibliity for users with low vision and those who are senstive to bright light.
        \n - Makes it easier for anyone nto use a device in a low-light environment.
    </string>
    <string name="UI_Look_AdaptiveIcon">AdaptiveIcon: \nIs the icon launcher, it used background image and foreground image to create the icon. Shapes of the icon can very from devices to firmware.</string>
    <string name="UI_Look_FAB">FAB: \nFloating Action Button, is a circular button that triggers the primary action in the activity. </string>
    <string name="UI_Look_Shadows">Shadows: \nMaterial design introduces elevation to help hep users understand the relative importance of each elements and focus their attention to the task at hand. Shadows are drawn by the parent of the elevated view and thus subject to standard view clipping.</string>
    <string name="UI_Look_clip">Clip: \nClipping views enables you to easily change the shape of a veiw. YOu can clip views for consistency with other design elemtns or to change the shape of a view in response to user input. you can clip a view to its outline are using the View.setClipTooutlIne</string>

    <string name="UI_widget_CardView">CardView: \n The CardView API shows information inside a card that have s a consistent look across the platform. These cards have default evlevation above their contiang view group s othe systme draws shadows below them. </string>
    <!--User Interface-->
    <string name="ui_switch_summary">Switch: Is a two-state toggle switch that can select between two options. The user may drag a thumb back and forth of tap to toggle. Switch compat is backwards compatible to API 7.</string>
    <string name="ui_tool_tip_summary">ToolTip: A Tool tip is a small is a small descriptive message that appears near a view when users long press the view or hover their mouse over it.</string>
    <string name="ui_notification_summary">Notification: provides short, timely information about events in your app while it\'s not in use.</string>
    <string name="ui_category_call_summary">CATEGORY_CALL: incoming call or similar synchronous communication request</string>
    <string name="ui_category_alarm_summary">CATEGORY_ALARM: Alarm or timer</string>
    <string name="ui_category_event">CATEGORY_EVENT: Notification category calendar event</string>
    <string name="ui_system_ui_summary">The System UI is screen bars dedicated to the display of notification, communication of device status, and device navigation. Typically the system bar displayed concurrently with the app.</string>
    <string name="ui_toast_summary">Toast: is a view containing a quick little message for the user, the view appears as a floating view over the application.</string>
    <string name="ui_snackbar_summary">Snackbar: Is attached to a view. The snackbar provides basic functionality if it is attached to any object derived from the view class</string>
    <string name="ui_place_holder_instructions">Click on an icon to move it to the center and in large it.</string>
    <string name="ui_motion_layout_summary">Motion Layout is a subclass of Constraint Layout, bridging he gap between layout transitions and complex motion handing, offering a mix of features between the property, animation framework, TransitionManager and Coordinator layout.</string>
    <string name="ui_radio_button_summary">RadioButton: is a two state button that can be checked or unchecked. Once check the user can\'t uncheck it.</string>
    <string name="ui_radio_group_summary">RadioGroup: is a multiple-exclusion scope for a set of radio buttons. Checking one RadioButton in the group will uncheck an previously checked button in the same group.</string>
    <string name="ui_toggle_button_summary">Toggle Button: Allows the user to change a setting between two states.</string>


</resources>